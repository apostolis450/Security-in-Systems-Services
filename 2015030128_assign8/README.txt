#-------------------------------------------------------------
#      AUTHOR : Zacharopoulos Aposolos            
#      SN     : 2015030128                         
#      Date   : 18 Dec, 2020                       
#-------------------------------------------------------------

---> Η ζητουμενη λειτουργια δουλευει ορθα εντος του gdb debbuger, διαφορετικα έχουμε απλα ενα segmentation fault
Για το payload injection χρησιμοποιηθηκε ενα shellcode που βρηκα στο διαδικτυο,γραμμενο σε Python.
Με την βοηθεια του gdb, βαζοντας ενα breakpoint πριν την επιστροφη της readString, μπορεσαμε να παρουμε τις εξης πληροφοριες.
Με την εντολη info frame, βλεπουμε την διευθυνση του instruction pointer, και δινοντας ως εισοδο για παραδειγμα "ΑΑΑΑΑΑΑΑΑ..."
μπορουμε να δουμε στην μνημη, απο το σημειο που ξεκιναει η διευθυνση buffer τον ascii αριθμο 0x41 αντιστοιχα,οσες φορες πληκτρολογησαμε
Α.
Εφοσον εχει αρχικοποιηθει ο buffer με μεγεθος 32, παρατηρηθηκε πως μέχρι το address του instruction pointer ,υπαρχουν αλλα 16 bytes αποσταση.
Ετσι, το payload αποτελειται απο (32+16) 48 Α,για να φτασουμε στην διευθυνση του $eip, ακολουθουμενο απο το νέο $eip που δινουμε, τον οποιο ειναι
το address του $eip+4 (0xffffd02c + 4 ) ,ακολουθουμενο απο 100  NOP bytes(0x90) και επειτα το shellcode για την εκκινηση του bash .
Έτσι, καταφερνουμε να μην εκτελεστει η εντολη που βρισκεται στην διευθυνση του %eip ,αλλα η δικια μας "κακοβουλη" ενεργεια.
Ωστοσο, παροτι παρθηκαν ολα τα μετρα, οπως η απενεργοποιηση του ASLR αλλα και τα καταλληλα flags που υπηρχαν ηδη (το αρχειο 
δεν ξαναεγινε compile οπως επισημαινεται και στην εκφωνηση), δεν ηταν δυνατο να τρεξει το shell που θελουμε. Στο περιβαλλον 
του gdb ωστοσο, αφου ειχε προηγηθει η εγγραφη του payload σε ενα input file ( python shellcode.py > /tmp/input) , η δοκιμη
 " r < /tmp/input " μας οδηγησε σε ενα shell , οπου λειτουργουσαν  κανονικα εντολες οπως whoami, ls κλπ.
 Εκτος gdb, η εντολη " python shellcode.py | ./Greeter " οδηγει απλα σε segm fault ή illegan instruction.
 Αυτο ισως οφειλεται σε καποιες enviroment variables του συστηματος, και πιθανον εκτος gdb η διευθυνση του $eip να ειναι μετατοπισμενη.
 -----> Στο αρχειο termsp.c βρίσκεται ένας κώδικας C για την δοκιμή του shellcode που θα χρησιμοποιηθεί. Παρότι δοκιμάστηκε με αρκετές παραμέτρους
  όπως ( -z execstack, -fno-stack-protector, mprotect μεσα στον κωδικα, ASLR off | gcc termsp.c -o test -z execstack -no-pie -fno-stack-protector) ,
   το αποτελεσμα ήταν συνεχώς segmentation fault.Δοκιμάστηκαν όλες οι 
  πιθανές λύσεις στο διαδίκτυο, χωρίς αποτέλεσματα. Πιθανόν υπάρχει κάποια προστασία στην μνήμη την οποια δε κατάφερα να απενεργοποιήσω
  ώστε να γίνει execute το shellcode. Η λογική πίσω απο το payload injection με buffer overflow ωστόσο πιστεύω ειναι η σωστή.

